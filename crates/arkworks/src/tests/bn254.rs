use crate::{curves::Bn254, CurveBasicOperations};
use ark_std::{ops::MulAssign, vec::Vec};
use rustc_hex::FromHex;

/// BN254 ADD
pub fn bn254_add() {
    // two one-points add encode
    let input1:Vec<u8> = FromHex::from_hex(
        "01000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000").unwrap();

    let res1 = Bn254::add(&input1[..]).unwrap();

    let expected :Vec<u8> = FromHex::from_hex(
        "d3cf876dc108c2d3a81c8716a91678d9851518685b04859b021a132ee7440603c4a2185a7abf3effc78f53e349a4a6680a9caeb2965f84e7927c0a0e8c73ed1500").unwrap();
    assert_eq!(res1, expected);
}

/// BN254 MUL
pub fn bn254_mul() {
    let input2:Vec<u8> = FromHex::from_hex(
        "0100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000308f03188746cbabf2f9329f32e6af3c1030c494557ec38d53380f9f5df6d10c").unwrap();

    let res2 = Bn254::mul(&input2[..]).unwrap();

    let expected :Vec<u8> = FromHex::from_hex(
        "1b67a829f225fa2dfd826ed9dfb6c63fbcb52bba72f01dd9dd84e4b426590e2a7a5f8b601e91a6d52374c844ece03b83757aabb9f093d411393febc5e827372200").unwrap();

    assert_eq!(res2, expected);
}

/// BN254 PAIRING
pub fn bn254_pairing() {
    // hex![(sa,b),(-sb,a)]
    let input:Vec<u8> = FromHex::from_hex(
                "cd660ea9af204d56e8536d2fc28c1038e761f1b8e236c0939457b52ab3c3cf11ce10c5d2da7a0cdaf335b66f66107e053c11b5b148b0ea71bac347607fca161400cfc276876571de255ca2cc081c753259f3fac8b28d037e4a17e9505cdcae4322699d38451ba0ef9d69fae88798f6ae96b949ea72a664c835d907bff7d73ced08c211bfd7b8217d9adbcc921ee4a78459e469349f1198db03febd76b79d39741de7671f7c1c8b1cbf4c40415923b9f65822a4001e9d96a8770b791eb74843aa14001b67a829f225fa2dfd826ed9dfb6c63fbcb52bba72f01dd9dd84e4b426590e2acd9df177f8fa79666956a923a5894514e8ddd5c7c5b17ba6f060461b8a262d0e00cfcebd6a33351e4a0d431fc1a7ce2966986a0c993f15ca044a536f7cc73e2518e379338e3f7c8cc191a8d0187244f842338949d93d1ed31a459f76761f5c080a23e18f756349c5075025f1eb76838dacc031c69f46f1298cdbb05f8a436e2d0ee32c918e061ee50b66ca36f12752f96563ad2ad3c4974ca5e1763c4c9dccd10000").unwrap();

    // e(sa, b) = e(sb, a)
    // e(sa, b) * e(-sb, a) = 1
    assert!(Bn254::pairings(&input[..]).expect("pairings failed"));
}

/// BN254 PAIRING SIX
pub fn bn254_pairing_six() {
    bn254_pairing();

    // check pairings
    {
        // hex![(a1, b1), (a2, b2), (-a1, b1), (-a2, b2)];
        let pairings_encoded = "0100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19aa7dfa6601cce64c7bd3430c69e7d1e38f40cb8d8071ab4aeb6d8cdba55ec8125b9722d1dcdaac55f38eb37033314bbc95330c69ad999eec75f05f58d08906090026052c2b69c54cc8029fcf0f0080f17ff0dad4e843466d144752112ea624960b63cc54e1673e2f2e7a0e0121cb3c7f7a7a2656713fc3fcc68f6f72dae6bdaa1300239480fea1f93725ff9dc1c9f59a62c73ac8dadfe87ca023dd32aa92416a8618d76f11482ffcbcc9a0943306c5cc62390b9ea0c6962420af6ad3e531c9f4802d3faf67b0fe4ee8264a63306f63c3612c1b2a6b26c3f76091167c2e4cbebfa501bd70cfd715766bdf9b512d3f5ef9bb131781b03d0359f7f5c28be067ae88ef2900010000000000000000000000000000000000000000000000000000000000000045fd7cd8168c203c8dca7168916a81975d588181b64550b829a031e1724e643000edf692d95cbdde46ddda5ef7d422436779445c5e66006a42761e1f12efde0018c212f3aeb785e49712e7a9353349aaf1255dfb31b7bf60723a480d9293938e19aa7dfa6601cce64c7bd3430c69e7d1e38f40cb8d8071ab4aeb6d8cdba55ec8125b9722d1dcdaac55f38eb37033314bbc95330c69ad999eec75f05f58d08906090026052c2b69c54cc8029fcf0f0080f17ff0dad4e843466d144752112ea624960be43028f7ae4df10d13bc7047c62d021de3312b10778253f19930bf068c90b91c00239480fea1f93725ff9dc1c9f59a62c73ac8dadfe87ca023dd32aa92416a8618d76f11482ffcbcc9a0943306c5cc62390b9ea0c6962420af6ad3e531c9f4802d3faf67b0fe4ee8264a63306f63c3612c1b2a6b26c3f76091167c2e4cbebfa501bd70cfd715766bdf9b512d3f5ef9bb131781b03d0359f7f5c28be067ae88ef2900";

        let input: Vec<u8> = FromHex::from_hex(pairings_encoded).unwrap();

        // check pairings operation:(a1*b1) * e(a2*b2) * e(-a1*b1) * e(-a2*b2) == 1 return true
        assert!(Bn254::pairings(&input[..]).unwrap());
    }
}

#[test]
fn test_bn256_additional() {
    // zero-points additions
    {
        let input:Vec<u8> = FromHex::from_hex(
            "00000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001").unwrap();

        let res = Bn254::add(&input[..]).unwrap();

        let expected :Vec<u8> = FromHex::from_hex(
            "0000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001").unwrap();

        assert_eq!(&expected[..], &res[..]);
    }

    // one-points additions
    bn254_add();
}

#[test]
fn test_bn256_scalar_mul() {
    bn254_mul();
}

// 30 times pairings
#[test]
fn test_bn256_pairing() {
    // test pairings
    for i in 0..5 {
        bn254_pairing_six();
    }
}
